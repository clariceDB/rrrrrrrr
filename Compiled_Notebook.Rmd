---
title: "Tidygraph and iGraph"
output:
  rmarkdown::html_document:
    theme: lumen
    toc: true
    toc_float: true
    toc_collapsed: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## <b>What is this all about?</b>
This Notebook demonstrates the complications that are encountered when trying to manipulate tinygraphs. As the name suggests, tidygraph is an entry into the tidyverse package that provides a tidy framework for all things relational (networks/graphs, trees, etc.). Tidygraph is a 'wrapper' for iGraph, which essentially means that all the functions that can be performed on tidygraphs can be performed on iGraphs. The issue here is that there are some functions that are not supported in the tidygraph package but is available to use in the iGraph package. 

If you are working with a tidygraph and you are forced to make use of an iGraph function, you will need to convert the tidygraph into an igraph, compute the function, and then convert it back to a tidygraph. So essentially, tidygraph lets you temporarily change the representation of your graph, do some manipulation of the node and edge data, and then change back to the original graph with the changes being merged in automatically.

In order to understyand this, we will demonstrate these conversions with the following functions:
  * transitivity
  * leiden
  * triad_census
  
----

## <b>Functions in more detail</b>

If you don't care about what the functions do, you can skip this section, however, for the purpose of fully understanding the issues that are encountered, let's take a look at them in more detail. 

### 1. <b>Transitivity</b>

<b>Usage:</b>
```
transitivity(graph, type = c("undirected", "global", "globalundirected",
  "localundirected", "local", "average", "localaverage",
  "localaverageundirected", "barrat", "weighted"), vids = NULL,
  weights = NULL, isolates = c("NaN", "zero"))
```

<b> What is transitivity?</b> transitivity measures the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient. We get local and global transitivity, which we discuss below:

#### <b>Global Transitivity</b>
> The global transitivity of an <b>undirected</b> graph (directed graphs are considered as undirected ones as well). This is simply the ratio of the triangles and the connected triples in the graph. For directed graph the direction of the edges is ignored.

#### <b>Local Transitivity</b>
> The local transitivity of an undirected graph, this is calculated for each vertex given in the vids (vertex ids) argument. The local transitivity of a vertex is the ratio of the triangles connected to the vertex and the triples centered on the vertex. For directed graph the direction of the edges is ignored.

Have a look at the parameters of the function by running the following command:
```
help(transitivity)
```

### 2. <b>Leiden Algorithm</b>

```
leiden(object, partition_type = c("RBConfigurationVertexPartition",
  "ModularityVertexPartition", "RBERVertexPartition", "CPMVertexPartition",
  "MutableVertexPartition", "SignificanceVertexPartition",
  "SurpriseVertexPartition"), initial_membership = NULL,
  weights = NULL, node_sizes = NULL, resolution_parameter = 1,
  seed = NULL, n_iterations = 2L)
```

This algorithm guarantees to find well-connected clusters within a network. By splitting clusters in a specific way, the Leiden algorithm guarantees that clusters are well-connected. Moreover, the algorithm guarantees more than this: if we run the algorithm repeatedly, we eventually obtain clusters that are subset optimal. This means that it is impossible to improve the quality of the clusters by moving one or more nodes from one cluster to another. We can use the Leiden algorithm to detect communities in networks.

Once again, if you want to understand the parameters of the Leiden functions, execute the following code:
```
help(leiden)
```

### 3. <b>Triad Census</b>

```
triad_census(graph)
```
<b> What is triad_census?</b> This function counts the different subgraphs of three vertices in a graph. To understand this we can look at the following example. Consider three nodes named A, B and C. Every triple of vertices (A, B, C) are classified into the 16 possible states, namely:

 > 003, 012, 102, 021D, 021U, 021C, 111D, 111U, 030T, 030C, 201, 120D, 120U, 120C, 210, 300
 
All of these states represent the different types of connections. For example, 012 suggests the following connection: A->B, C (which is a graph with a single directed edge). Another example is 102 which represents A<->B, C (the graph with a mutual connection between two vertices). The other states will be discussed later on in this tutorial. 

Lastly, if you want to know exactly how the function works, execute the following code:
```
help(triad_census)
```
----

## <b>Demonstrations</b>

Now that we've covered the theoretical aspects of the functions, let's investigate the above-mentioned functions in finer detail. 

### <b>Transitivity</b>

Let's load the required packages: 
```{r Load packages}
pacman::p_load(randomNames, tidygraph, tidyverse, igraph, ggraph)
```

For demonstration purposes, we'll be using the enron dataset. The `email-enron-only.mtx` file contains all emails sent between employees, which can be represented by nodes and edges.

```{r Dataset, message=FALSE, warning=FALSE}
# Load the enron dataset
enron <- read_delim("email-enron-only.mtx",delim = " ",col_names = F) %>% 
  rename("from" = X1,
         "to" = X2) %>% 
  graph_from_data_frame()

# Add the employees names the vertices of the enron graph
V(enron)$name <- randomNames(144, which.names="first")
```

Before we move on, note that enron is of type `igraph`. To check this, you can run `class(enron)`. In the next chunk we test the global and local transitivity.

```{r}
# Global transitivity
transitivity(enron)
```


```{r}
# Local transitivity
transitivity(enron, vids = "Kayla", type = "local")
```


Next, we 

```{r}

```



```{r}
enron_tib <- as_tbl_graph(enron)
#Attempting to convert to a tibble graph to use in certain situations if need be

class(enron_tib)
#One can see by the second output that it didnt change from igraph to tbl_graph but now takes on both. 
#This is because tbl_graph is a subset of igraph

igraph::transitivity(enron_tib)
tidygraph::transitivity(enron_tib)
#Bottom two is a metric and an error message. This is because this function can only be run in igraph and not in tidygraph. It is rare but there may be cases where igraph can do things that tidygraph cannot. 
```
```{r}
#If one then needs to convert to igraph to use it then use the following conversion code
igraph_test <- as.igraph(enron_tib)
class(igraph_test)

#If one then needs to convert to tbl_graph to use it then use the following conversion code
#You can not drop the igraph, but if your class was just igraph then run the above conversion code to use enron as a tbl_graph
tbl_graph_test <- as_tbl_graph(enron_tib)
class(tbl_graph_test)
```

----



